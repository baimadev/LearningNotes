## synchronized

保证可见性、原子性（只有单线程操作变量）、有序性（单线程的指令重排没有影响）

重量级锁，同一时间只有一个线程在执行，其他未获取到锁的线程进入对象的锁池队列并进入阻塞状态放弃CPU执行权，因为切换线程需要在cpu用户态和内核态之间切换，线程切换频繁造成资源浪费。 -- 悲观锁

### 锁类对象

对该类的所有实例都起作用。

```java

    public static synchronized  void test(){}

    public void test(){
      synchronized(Singleton.class){

      }
    }


```

### 锁实例对象

```java

    public synchronized  void test(){}

    public void test(){
          synchronized(this){

          }
    }

    //锁的是lock对象
    public void test(){
        String lock = "";
        synchronized(lock){

        }
    }


```

### 原理

每个对象拥有一个monitor。想要进入同步代码块，首先得获取对象的monitor，获取后线程继续执行，否则只能等待。进入同步代码块后会执行monitorenter，退出会执行monitorexit指令。

### 可重入性
同一线程对同一个对象锁是可重入的，而且同一个线程可以获取同一把锁多次，也就是可以多次重入。

每一个可重入锁都会关联一个线程和一个锁计数器。

当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。
释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。
释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。

所以，从一定程度上来说，可重入锁可以避免死锁的发生。

### 可见性

1）线程解锁前，必须把共享变量的最新值刷新到主内存中  

2）线程加锁时，从主存中重新获取最新的值


## CAS
而CAS（compare and swap）操作（又称为无锁操作）是一种乐观锁策略。

使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。

### CAS原理

CAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值。当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。

### ABA
一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。CAS会判定为操作成功，多出来的过程可能会引起预料之外的结果。

解决办法：添加一个版本号。每次赋值操作带一个版本号，CAS操作时对版本号进行判断，操作成功版本号+1。

## 锁升级

锁升级实质上是Object的markword（对象头）里面标志位的变化。

### 偏向锁

- 1.线程1访问同步代码块 -> 检查对象头中的线程ID是否指向自己 -> 若没有则CAS操作对象头指向自己

- 2. 其他线程尝试获取锁 -> 检查对线头中的线程ID是否指向自己 -> 若没有则CAS操作 -> 已指向其他线程 -> 操作失败，撤销偏向锁 -> 暂停线程，将对线头中的线程ID设为null -> 恢复线程

总结：不存在竞争直接执行同步代码块，存在竞争撤销偏向锁，升级为轻量锁。

### 轻量锁

每个线程在自己的线程栈中生成LockRecord，用CAS操作将markword设置为指向自己线程的LR指针，设置成功得到锁。轻量级锁在加锁过程中用到了自旋。

默认自旋10次，超过次数后升级为重量级锁。

### 重量级锁

重量级锁就是原理synchronized那一套，让操作系统调度线程。  
线程挂起，进入等待队列，等待操作系统调度，然后再映射回到用户空间。  
这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能。

### 锁消除

锁消除理解：方法中锁住的对象没有被共用扩散(比如方法中的局部变量)，不管被当前线程或者下一个线程访问，都没什么区别，**每个人都可以拿一份锁**，都可以进入新的对象空间，没意义。JVM 会自动消除对象内部的锁。

### 锁粗化

锁粗化理解：假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块， 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能。


## ReentrantLock

代码层面控制锁的获取与释放；synchronized是通过操作系统的monitor来控制锁的获取与释放。

实现Lock接口，通过CAS操作去获取锁。


### 可重入锁

线程已获取锁的情况下再次获取锁，线程不会阻塞，锁计数器+1，释放时-1。

重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，只有被释放n次才算成功释放，返回true。

### 公平锁和非公平锁
ReentrantLock支持公平锁和非公平锁，默认非公平锁。
如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO。

线程需在队列中排队获取锁。



## [JMM](https://juejin.cn/post/6844903600318054413)

## 指令重排
不改变程序执行结果的前提下，尽可能提高并行度。
为了提高性能，编译器和处理器常常会对指令进行重排序。

## as if serial

不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。

## happens before

如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！

as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。

在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。

## DCL缺陷

```java
class Faith {
    private static Faith myFaith = null;
    private Faith(){
        System.out.println(Thread.currentThread().getName()+" --- Faith.Faith --- 私有构造调用了");
    }

    public static Faith getMyFaith() {
        // 第一次判断，若myFaith实例为空
        if (myFaith == null){
            // 加同步锁
            synchronized (Faith.class) {
                // 第二次判断，若myFaith实例确实为空，进入构造方法
                if (myFaith == null) {
                    myFaith = new Faith();
                }
            }
        }
        return myFaith;
    }
}
```

### 指令重排分析

myFaith = new Faith(); 该方法其实有3步：  

1、分配内存空间和内存地址  
`memeory = allocate;`

2、初始化对象  
`myFaith(memory);`

3、将实例指向分配的内存地址    
`myFaith = memory;`

第二步和第三步没有数据依赖关系，单线程下指令重排不影响执行结果，因此编译器和cpu允许重排优化的行为。

**依赖关系**：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。


即可能出现第三步先于第二部执行， myFaith = memory; 此时因为已经给即将创建的myFaith分配了内存空间，所以myFaith!=null，但对象的初始化还没有完成，造成线程安全问题。

### volatile禁止指令重排

保证有序性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

`private static volatile Faith myFaith = null;`

### volatile可见性

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
