# Java垃圾回收机制

## 可达性分析算法

从GC Roots开始寻找它的引用节点，然后再找引用节点的引用节点，当所有节点都找完了，没有在这条引用链上的节点为不可达对象。

Gc Roots:

- 虚拟机栈中引用的对象（栈帧的局部变量表）
- 本地方法栈中引用的对象（Native对象）
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象

## 垃圾收集算法

### 标记清除

标记阶段：标记出需要被回收的对象。
清除阶段：回收被标记的可回收对象的内部空间。

特点：
- 需要暂停整个应用，效率不高
- 会产生大量不连续的内存碎片

### 复制算法

将内存分为两块，每次只使用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。

特点：
- 不易产生内存碎片，每次只需要对半个区进行内存回收。
- 内存空间缩减为原来的一半；算法的效率和存活对象的数目有关，存活对象越多，效率越低。

### 标记整理

标记阶段：标记出需要被回收的对象。
清除阶段：将存活对象都向一端移动，然后清理掉端边界以外的内存。

### 分代收集

一般情况下将堆区划分为老年代和新生代，老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采取最适合的收集算法。

#### 新生代
MinorGC频率高，对象存活率低。

所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。  
新生代采用复制算法，将内存分为三份8:1:1。


#### 老年代
在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。

MajorGC频率低，对象存活率高，采用标记整理，


## 引用类型

### 强引用（StrongReference）

强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。

### 软引用（SoftReference）

如果内存空间不足了，就会回收这些对象的内存。

### 弱引用（WeakReference）

GC时一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

### 虚引用（PhantomReference）

“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

ReferenceQueue 联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。因此我们可以通过判断队列中是否存这个对象，来进行回收前的一些处理。
