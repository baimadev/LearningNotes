##Kotlin委托


在做项目时看到一个这样的委托用法。

```
    var dataList: MutableList<ResultVideo> by Delegates.observable(mutableListOf()) { 
    property, oldValue, newValue ->
        notifyDataSetChanged()
    }
```
  用在RecyclerViewAdapter中，外部给dataList赋值时，回调自动刷新RecyclerView显示。
  
  Delegates.observable这个委托会帮我们监测我们希望观察的属性的变化.当被观察属性的 set 方法被调用的时候，它就会自动执行我们指定的lambda表达式。
  
  ```
      public inline fun <T> observable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit):
            ReadWriteProperty<Any?, T> =
        object : ObservableProperty<T>(initialValue) {
            override fun afterChange(property: KProperty<*>, oldValue: T, newValue: T) = onChange(property, oldValue, newValue)
        }
  ```
  
它的实现也不是很难，函数observable接收一个初始值和一个lambda表达式，返回了一个**ReadWriteProperty**类型，它是一个接口，里面含有getValue和setValue方法，这样就能通过by关键字来代理属性。这里的**ObservableProperty**继承了**ReadWriteProperty**（**ReadOnlyProperty**则只包含getValue，适用于val）。

```
public abstract class ObservableProperty<T>(initialValue: T) : ReadWriteProperty<Any?, T> {
    private var value = initialValue

    //给value赋值时的回调，返回true则值已改变，false则未变。
    protected open fun beforeChange(property: KProperty<*>, oldValue: T, newValue: T): Boolean = true
	//value变化时的回调。
    protected open fun afterChange(property: KProperty<*>, oldValue: T, newValue: T): Unit {}

    public override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        return value
    }

    public override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
        val oldValue = this.value
        if (!beforeChange(property, oldValue, value)) {
            return
        }
        this.value = value
        //value值发生变化回调afterChange，然后再回调我们设定的lambda,达到对属性变化监听的作用。
        afterChange(property, oldValue, value)
    }
}
```
然后我自己也试着写了一个委托方法。

```
@Suppress("UNCHECKED_CAST")
fun <T> extraDelegate(extraName: String, defaultValue: T? = null) =
    object : ReadOnlyProperty<AppCompatActivity, T?> {
        override fun getValue(thisRef: AppCompatActivity, property: KProperty<*>): T? {
            return defaultValue ?: thisRef.intent?.extras?.get(extraName) as T?
        }

    }
```
在AppCompatActivity中可使用此代理获取IntentExtra。

```
val intent =Intent(this,Main2Activity::class.java)
            intent.putExtra(Main2Activity.EXTRA_USER_ID,"01")
            startActivity(intent)
```

然后这样调用：

 `private val u:String? by extraDelegate(EXTRA_USER_ID)`

然而好像并没有省去多少代码。

如果使用DataBinding的话，在RecyclerView中还可以这样写

```
//ObservableList内部就提供了很多list改变时的回调接口。
protected val mDataList: ObservableList<Any>

private fun initCallback() {
        mDataList.addOnListChangedCallback(object : ObservableList.OnListChangedCallback<ObservableList<Any>>() {

            override fun onChanged(sender: ObservableList<Any>) {
                notifyDataSetChanged()
            }

            override fun onItemRangeChanged(sender: ObservableList<Any>, positionStart: Int, itemCount: Int) {
                notifyItemRangeChanged(positionStart, itemCount)
            }

            override fun onItemRangeInserted(sender: ObservableList<Any>, positionStart: Int, itemCount: Int) {
                notifyItemRangeInserted(positionStart, itemCount)
            }

            override fun onItemRangeMoved(sender: ObservableList<Any>, fromPosition: Int, toPosition: Int, itemCount: Int) {
                if (itemCount == 1) {
                    notifyItemMoved(fromPosition, toPosition)
                } else {
                    notifyDataSetChanged()
                }
            }

            override fun onItemRangeRemoved(sender: ObservableList<Any>, positionStart: Int, itemCount: Int) {
                notifyItemRangeRemoved(positionStart, itemCount)
            }
        })
    }
```


---

##RxBus&LiveDataBus

```
class RxBus private constructor(){
    private val mBus=PublishSubject.create<Any>().toSerialized()
    companion object{
        val instance: RxBus by lazy { RxBus() }
    }


    fun <T>toObservable(eventType:Class<T>):Observable<T>{
        return mBus.ofType(eventType)
    }

    fun postEvent(event:Any){
        mBus.onNext(event)
    }


      fun hasObservablers():Boolean{
        return mBus.hasObservers()
    }

}
```
之前自己做即时通讯应用时用到的Rx消息分发，当然也是copy的。但使用这种方法我们要在页面销毁时取消订阅，不然会影起内存泄漏。由于我们订阅事件时是根据事件类型来进行的，所以我们有多个观察者时，它们都会接收到事件。所以我又去Copy了个LiveDataBus。

LiveDataBus写法也很简单。

+ 首先我们需要个` private val bus: MutableMap<String, MutableLiveData<Any>> = HashMap()`来存放我们的事件。
+ 订阅事件


```
fun <T> with(key: String, type: Class<T>): MutableLiveData<T> {
        if (!bus.containsKey(key)) {
            bus[key] = MutableLiveData()
        }
        return bus[key] as MutableLiveData<T>
    }
    
fun with(key: String): MutableLiveData<Any> {
        return with(key, Any::class.java)
    }

fun <T>subscribe(key: String,type: Class<T>,owner: LifecycleOwner ,observer: (T) -> Unit ){
            defaultBus.with(key,type).observe(owner,Observer<T>{
                observer.invoke(it)
            })
        }
```
然后通过
```LiveDataBus.subscribe("str", String::class.java,this){
            Log.e("xia",it)
        }```
        来订阅事件。

+ 发送事件
`LiveDataBus.defaultBus.with("str").value="test"`

LiveDataBus最大的优点就是能够感知生命周期，避免了内存泄漏，实现简单。而且这样写可以用不同的Key发送相同类型的事件，不会出现RxBus那种发送一个事件，多个观察者都收到的情况。

*注意：LiveData内部有一个version值初始为-1，当我们调用setValue时，其version+1;对于每一个观察者的封装ObservableWrapper初始version也为-1，当LiveData设置这个ObservableWrapper时，如果LiveData的version大于ObservableWrapper的version，LiveData就会强制把当前value推送给Observer。这样会导致订阅者会收到订阅之前发布的消息*

有兴趣的话推荐看这篇文章[LiveDataBus](https://tech.meituan.com/2018/07/26/android-livedatabus.html)，他是使用反射来解决这个问题的。




---

##autoProgressDialog
```
fun <T> Single<T>.autoProgressDialog(progressDialog: MutableLiveData<Boolean>): Single<T> =
    compose {                                        
        it
            .doOnSubscribe { progressDialog.showProgressDialog() } 
            .doOnDispose { progressDialog.hideProgressDialog() }
            .doOnError { progressDialog.hideProgressDialog() }
            .doOnSuccess { progressDialog.hideProgressDialog() }
    }
```
当时第一次看到这样的写法，就只感叹了一句，卧槽牛逼。

后来还看到一种有类似功能的写法，用的ViewModel和ObservableField,可以很简单的调用，然后显示不同的加载状态。

```
abstract class BaseActivity<DB : ViewDataBinding, VM : BaseViewModel> : AppCompatActivity() {

    protected lateinit var mDataBinding: DB
        private set

    protected var mViewModel: VM? = null

    private lateinit var mActivityBaseBinding: ActivityBaseBinding

    private var mViewLoadingBinding: ViewLoadingBinding? = null

    private var mViewLoadErrorBinding: ViewLoadErrorBinding? = null

    private var mViewNoNetworkBinding: ViewNoNetworkBinding? = null

    private var mViewNoDataBinding: ViewNoDataBinding? = null
    
    private var mLoadStateCallback: Observable.OnPropertyChangedCallback? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    
        mActivityBaseBinding = DataBindingUtil.setContentView(this, R.layout.activity_base)
        mDataBinding = DataBindingUtil.inflate(layoutInflater, getLayoutResId(),
                mActivityBaseBinding.flContentContainer, true)

        if (isSupportLoad()) { //默认false
            initLoadState()
        }
    }

  
    private fun initLoadState() {
        mViewModel?.run {
            mLoadStateCallback = object : Observable.OnPropertyChangedCallback() {

                override fun onPropertyChanged(sender: Observable?, propertyId: Int) {
                //loadState 是baseViewModel中ObservableField<LoadState>包裹的枚举类，有多种加载状态。
                    loadState.get()?.run { switchLoadView(this) }
                }
            }
            //设置属性值改变时的回调
            loadState.addOnPropertyChangedCallback(mLoadStateCallback!!)
        }
    }

    private fun removeLoadView() {
        val childCount = mActivityBaseBinding.flContentContainer.childCount
        if (childCount > 1) {
            mActivityBaseBinding.flContentContainer.removeViews(1, childCount - 1)
        }
    }

    //跟据不同的状态加载不同的layout
    private fun switchLoadView(loadState: LoadState) {
        removeLoadView()
        
        when (loadState) {
            LoadState.LOADING -> {
                if (mViewLoadingBinding == null) {
                    mViewLoadingBinding = DataBindingUtil.inflate(layoutInflater, R.layout.view_loading,
                            mActivityBaseBinding.flContentContainer, false)
                }
                mActivityBaseBinding.flContentContainer.addView(mViewLoadingBinding?.root)
            }

            LoadState.NO_NETWORK -> {
                if (mViewNoNetworkBinding == null) {
                    mViewNoNetworkBinding = DataBindingUtil.inflate(layoutInflater, R.layout.view_no_network,
                            mActivityBaseBinding.flContentContainer, false)
                    mViewNoNetworkBinding?.viewModel = mViewModel
                }
                mActivityBaseBinding.flContentContainer.addView(mViewNoNetworkBinding?.root)
            }

            ...

           
        }
        
  override fun onDestroy() {
        super.onDestroy()
        mViewModel?.run {
            if (mLoadStateCallback != null) {
                loadState.removeOnPropertyChangedCallback(mLoadStateCallback!!)
            }
        }
    }
    }
```
使用时就只需要给loadState赋值就行了。` loadState.set(LoadState.NO_DATA)`