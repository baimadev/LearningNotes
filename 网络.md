## 网络分层
应用层  HTTP FTP
传输层  TCP UDP
网络层  IP
数据链路层
物理层

TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。

## TCP和UDP

- TCP 是面向连接的，UDP 是面向无连接的
- UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式。
- TCP 是面向字节流的，UDP 是基于数据报的
- TCP 保证数据正确性，UDP 可能丢包

## Socket

Socket不是协议，是对TCP/IP的封装。

创建Socket连接时，可以指定使用的传输层协议，例如TCP、UDP。

通过ip:port去连接C/S,server会一直监听端口，直到有客户端请求建立连接。

## HTTP

Http协议是基于TCP链接的。http协议是建立在TCP协议之上的一种应用。

### HTTP 1.0

- 客户端的每次请求都要建立一次单独的连接，在处理完成请求后，就自动释放连接。
- 明文传输

### HTTP 1.1

支持长链接，但是是串行的。

### HTTP 2.0

多路复用，多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。

## HTTPS

经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。  

### 连接过程

- 1.客户端向服务端发起Https请求
- 2.服务端将证书和公钥发给客户端
- 3.客户端验证证书
- 4.客户端信任证书后和服务端商量加密算法
- 5.客户端将加密算法用服务端的公钥加密传输
- 6.服务端私钥解密，之后就用这种对称加密方式通信


利用了对称加密和非对称加密。  
对称加密：客户端和服务器商量出来的加密算法。  
非对称加密：商量出来的加密算法，客户端通过公钥加密传给服务端，服务端再通过私钥解密。

### 验证证书

在向CA 申请证书时是需要 CA的私钥 去对整个证书的签名摘要做非对称加密的，也就是证书是可以通过 CA的公钥 去解密得到证书的签名摘要的。当我们再次用 相同的摘要算法（证书里面有保存所使用的算法）对整个证书做签名，如果得到的签名和证书上的签名是一致的，说明这个证书是可信任的。

## 三次握手四次挥手

![](img/connect.jpg)

握手过程：  
第一次握手：客户端发送syn包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认;  

第二次握手：服务器收到syn包，必须确认客户的SYN(ack=x+1)，同时自己也发送一个SYN包(seq=y)，即SYN+ACK包，此时服务器进入SYN_RECV状态;  

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态。

为什么要三次握手？  
需要三次握手才能确认双方的接收与发送能力是否正常。


挥手过程：
第一次挥手：客户端发送一个FIN（FIN=1，序号seq=u），并停止再发送数据，但此时还可以接收数据。此时客户端处于 FIN_WAIT1 状态。

第二次挥手：服务端收到FIN包后，发送一个ACK给对方（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT状态。客户端收到服务端的确认后，进入FIN_WAIT2状态，等待服务端发出的连接释放报文段。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），且指定一个序列号。此时服务端处于 LAST_ACK 的状态，等待客户端的确认。

第四次挥手：客户端收到FIN后，发送一个ACK给被动关闭方，客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

等待2MSL的意义?
为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
